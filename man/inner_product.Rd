% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/00_generic.R, R/05_basis.R, R/08_fourier.R, R/10_bspline.R, R/15_fd.R
\docType{methods}
\name{\%*\%}
\alias{\%*\%}
\alias{\%*\%,basis+,basis+-method}
\alias{\%*\%,basis+,fd+-method}
\alias{\%*\%,bspline+,bspline+-method}
\alias{\%*\%,fd+,basis+-method}
\alias{\%*\%,fd+,fd+-method}
\alias{\%*\%,fourier+,fourier+-method}
\alias{inner_product}
\title{Calculating Inner Products between Functional Data Objects}
\usage{
x \%*\% y

\S4method{\%*\%}{`basis+`,`basis+`}(x, y)

\S4method{\%*\%}{`fourier+`,`fourier+`}(x, y)

\S4method{\%*\%}{`bspline+`,`bspline+`}(x, y)

\S4method{\%*\%}{`fd+`,`fd+`}(x, y)

\S4method{\%*\%}{`fd+`,`basis+`}(x, y)

\S4method{\%*\%}{`basis+`,`fd+`}(x, y)
}
\arguments{
\item{x,y}{Objects of classes \code{\link[=basis+-class]{basis+}},
\code{\link[=fd+-class]{fd+}} or \code{\link[=bifd+-class]{bifd+}}.}
}
\value{
See \strong{Method (...)} sections for the explanation of various
        types of results.
}
\description{
This generic function provides methods to calculate inner products between
functional data objects (basis functions, univariate functions and bivariate
functions).
}
\section{Method (basis vs basis)}{

\code{x} and \code{y} are two \code{\link[=basis+-class]{basis+}} objects,
not necessarily of the same type (for example, one can be
\code{\link[=bspline+-class]{bspline+}} and the other be
\code{\link[=fourier+-class]{fourier+}}).

Assume that \code{x} contains \code{m} functions and \code{y} contains
\code{n} functions, and then \code{x \%*\% y} returns an \code{m} by \code{n}
matrix \code{P}, whose element \code{P[i, j]} is the inner product between
the \code{i}-th function of \code{x} and the \code{j}-th function of \code{y}.
}

\section{Method (univariate function vs univariate function)}{

\code{x} and \code{y} are two \code{\link[=fd+-class]{fd+}} objects
which we do not require to have the same types of basis functions.

Assume that \code{x} contains \code{m} functions and \code{y} contains
\code{n} functions, and then \code{x \%*\% y} returns an \code{m} by \code{n}
matrix \code{P}, whose element \code{P[i, j]} is the inner product between
the \code{i}-th function of \code{x} and the \code{j}-th function of \code{y}.
}

\section{Method (univariate function vs basis)}{

Assueme that \code{x} is an \code{\link[=fd+-class]{fd+}} object and \code{y}
a \code{\link[=basis+-class]{basis+}} object (or vice versa). We do not require
\code{x} to have the same basis as \code{y}.

If \code{x} contains \code{m} functions and \code{y} contains
\code{n} functions, then \code{x \%*\% y} returns an \code{m} by \code{n}
matrix \code{P}, whose element \code{P[i, j]} is the inner product between
the \code{i}-th function of \code{x} and the \code{j}-th function of \code{y}.
}
\author{
Yixuan Qiu <\url{http://statr.me/}>
}

